#include "tdmsReader/TdmsParser.h"
#include "tdmsReader/TdmsGroup.h"
#include "tdmsReader/TdmsChannel.h"
#include <TBranch.h>
#include <TParameter.h>
#include <TString.h>
#include <TObjString.h>
#include <TList.h>
#include <TDatime.h>
#include <cstdint>
#include <cstdio>
#include <math.h>
#include <memory>
#include <string.h>
#include <cstdlib>
#include <TTree.h>
#include <TFile.h>
#include <string>
#include <vector>

void help()
{
	std::cout << "Use: tdmsreader -option your_file_name.tdms" << std::endl;
	std::cout << "Options:" << std::endl;
	std::cout << "-h: print help information and exit" << std::endl;
	std::cout << "-p: display channel properties" << std::endl;
	std::cout << "-s: store channel data values" << std::endl;
	std::cout << "-v: verbose output" << std::endl;
}

class BranchStruct
{
public:
	std::vector<uint8_t > WCM;
	std::vector<uint16_t> MAX;
	std::vector<uint32_t> TOT;
	std::vector<uint32_t> INTEGRAL;
	std::vector<uint32_t> TIME;
	std::vector<uint64_t> COUNTER;
};

void errorMessage()
{
	std::cout << "\nInput error: please provide a single valid *.tdms file name!" << std::endl;
}

int main(int argc, char *argv[])
{
	if (argc < 2){
		std::cout << "Use: tdmsreader your_file_name.tdms" << std::endl;
		errorMessage();
		return 0;
	}

	if ((argc == 2) && (strcmp(argv[1], "-h") == 0)){
		help();
		exit(0);
	}

	bool verbose = false, storeValues = true, showProperties = false;
	if ((argc == 3) && (strchr(argv[1], '-'))){
		if (strchr(argv[1], 'p'))
			showProperties = true;
		if (strchr(argv[1], 's'))
			storeValues = true;
		if (strchr(argv[1], 'v'))
			verbose = true;
	}

	std::string fileName = (argc == 3) ? argv[2] : argv[1];
	TdmsParser parser(fileName, storeValues);
	if (parser.fileOpeningError()){
		errorMessage();
		return 0;
	}

	printf("Parsing TDMS File: %s \n", fileName.c_str());
	parser.read(verbose);

	unsigned int groupCount = parser.getGroupCount();
	printf("\nNumber of groups: %d\n", groupCount);

	std::unique_ptr<TFile> outFile(TFile::Open("testFile.root", "RECREATE"));
	TTree *tree = new TTree("T", "ACTUALLY THE TREE");

	BranchStruct bs[8];

	for (unsigned int i = 0; i < groupCount; i++){

		TdmsGroup *group = parser.getGroup(i);
		if (!group) continue;

		unsigned int channelsCount = group->getGroupSize();
		if (channelsCount == 0) continue;

		printf("Processing group %d\n", i);

		auto tree = std::make_unique<TTree>("T_Pulse", "");

		/* printf("Group object property count %d\n",group->getObject()->getPropertyCount()); */
		/* printf("Properties:\n"); */

		int _item = 0;
		for (auto item : group->getObject()->getProperties()) {
			printf(" - %s, %s\n", item.first.c_str(), item.second.c_str());

			if (_item == 3 || _item == 13 || _item == 22) {
				auto p = new TObjString((item.first + ": " + item.second).c_str());
				tree->GetUserInfo()->Add(p);
			}
			else if (_item == 12) {
				auto p = new TParameter<bool>(item.first.c_str(), item.second == "True");
				tree->GetUserInfo()->Add(p);
			}
			else {
				auto p = new TParameter<float>(item.first.c_str(), std::stof(item.second));
				tree->GetUserInfo()->Add(p);
			}

			_item++;
		}

		/* printf("\nGroup %s (%d/%d) has %d channels:\n\n", group->getName().c_str(), i + 1, groupCount, channelsCount); */

		int dataID = 0;
		int channelID = 0;
		for (int j = 0; j < channelsCount; j++) {
			TdmsChannel *ch = group->getChannel(j);
			if (!ch) continue;
			if (ch->getDataCount() == 0) continue; 
			/* printf("%d: Channel %s has %lld data, %lld values, %d properties\n", j + 1, */ 
			/* 																	 ch->getName().c_str(), */ 
			/* 																	 ch->getDataCount(), */ 
			/* 																	 ch->getValuesCount(), */ 
			/* 																	 ch->getPropertyCount()); */

			if      (dataID == 0) bs[channelID].WCM		 = std::vector<uint8_t >(ch->getDataVector().begin(), ch->getDataVector().end());
			else if (dataID == 1) bs[channelID].MAX		 = std::vector<uint16_t>(ch->getDataVector().begin(), ch->getDataVector().end());
			else if (dataID == 2) bs[channelID].TOT   	 = std::vector<uint32_t>(ch->getDataVector().begin(), ch->getDataVector().end());
			else if (dataID == 3) bs[channelID].INTEGRAL = std::vector<uint32_t>(ch->getDataVector().begin(), ch->getDataVector().end());
			else if (dataID == 4) bs[channelID].TIME	 = std::vector<uint32_t>(ch->getDataVector().begin(), ch->getDataVector().end());
			else if (dataID == 5) bs[channelID].COUNTER  = std::vector<uint64_t>(ch->getDataVector().begin(), ch->getDataVector().end());

			if (++dataID == 6) 
			{
				auto wcm_n = "wcm" + std::to_string(j/6);
				auto max_n = "max" + std::to_string(j/6);
				auto tot_n = "tot" + std::to_string(j/6);
				auto integral_n = "integral" + std::to_string(j/6);
				auto time_n = "time" + std::to_string(j/6);
				auto counter_n = "counter" + std::to_string(j/6);

				tree->Branch(wcm_n.c_str(), &(bs[channelID].WCM));
				tree->Branch(max_n.c_str(), &(bs[channelID].MAX));
				tree->Branch(tot_n.c_str(), &(bs[channelID].TOT));
				tree->Branch(integral_n.c_str(), &(bs[channelID].INTEGRAL));
				tree->Branch(time_n.c_str(), &(bs[channelID].TIME));
				tree->Branch(counter_n.c_str(), &(bs[channelID].COUNTER));
				channelID++;

				dataID = 0;
			}
		}
		tree->Fill();
		tree->Write();
	}

	/* tree->Write(); */
	outFile->Close();

	printf("\nSuccessfully parsed file '%s' (size: %lld bytes).\n", fileName.c_str(), parser.fileSize());
	printf("Done!\n");
	return 0;
}
